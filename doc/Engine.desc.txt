Описание принципа работы движка Ninja engine (Deku team 2d engine)

Для использования движка достаточно добавить строку #include "Ninja.h".
Пример простейшей программы:

#include "Ninja.h"

CNinja *engine = CNinja::Instance(); // получение указателя на экземпляр основного класса.

int main(int argc, char *argv[])
{
	Ninja->Run();
	Ninja->FreeInst();
	return 0x0;	
}

Такая программа будет работать, да.

Все классы приложения, ипользующего движок и желающие быть отрисованными должны быть унаследованы от 
класса CRenderObject и иметь процедуру bool Draw();
	
Аналогично, если необходимо каждый раз обновлять объект, требуется унаслдовать его от CObject и создать в нём
функцию bool Update(float dt);  В конструкторе класса следует написать присвоение:
	type |= T_UPDATABLE; // пофиксь имя константы мудло

Для осуществления обновления и отрисовки все экзмепляры таких, унаследованных от базовых классов движка объектов
следует создавать только так:
	CFactory *Factory = CFactory::Instace();
	object = (<objecttype>) Factory->create(OBJ_USER_DEFINED, &(<objecttype>::<crfunc name>));
	OBJ_USER_DEFINED - эта константа говорит фабрике тип обхекта, который надо создать
	<objecttype>::<crfunc name> Это ф-я, которую следует объявить примерно так:
	
class СUser: public CRenderObject
{
public:
	CEnemy(){}
	static CObject*	NewEnemy()
	{
		return new СUser;
	}


Создавая объекты таким образом мы добъемся отхвата момента создания каждого из объектов. В этот момент их можно запомнить,
и добавить во все нужные менеджеры.

Фактически игру, т.е. меню, переходы с карты на карту, скриптовые сценки, диалоги ит.д. мы будем делать скриптом.
Скрипты еще даже не начали писать.

Можно расширить базовую программу до:

#include "Ninja.h"

CNinja* Ninja = CNinja::Instance();
bool Init()
{	
	return true;
}

bool Draw()
{	
	return true;
}

bool Update()
{
	return true;
}

int	main(int argc, char *argv[])
{
	Ninja->SetState(STATE_UPDATE_FUNC, &Update);
	Ninja->SetState(STATE_RENDER_FUNC, &Draw);
	Ninja->SetState(STATE_USER_INIT, &Init);
	
	Ninja->Run();
	Ninja->FreeInst();
	return 0x0;
}

Таким образом мы попросим движок вызвать нашу инициализацию в самом начале, и каждый кадр вызывать Update() и Draw().
(На самом деле не каждый, но это потом)

Отсюда впринципе понятно, что CFactory - это фабрика объектов, она призвана создавать все игровые объекты, которые хотят,
чтобы движок знал об их существовании.
CFactory унаследован от CObjectList, это позовляет ему хранить список вообще всех созданых объектов. И удалять их после всех.

Основной класс движка - CNinja. Из этого вытекаеют его задачи, такие как инициализация, загрузка всего, предоставлению пользователю
доступа к менеджерам(о них попожжа), основной цикл, ну и так далее. Это пользователя особо не касается.

Также существует ряд менеджеров различных типов объектов, все менеджеры унаследованы от CObjectList, и хранят список объектов,
принадлежащих данному менеджеру. Доступ к ним осущ-ся с помощью CNinja, если это необходимо.

Менеджеры наполняются объектами исключительно с помощью CFactory.
Немаловажен тот факт, что поскольку менеджеров становиться всё больше и больше, неплохо было бы написать класс
наподобоие CManagerManager. Это шутка была, да, хахаха.

Ёбаны.

На данный момент в классе CNinja есть такие манагеры:

CFontManager
CUpdateManager
CRenderManager
CResourseManager

У меня есть предчувствие что понадобится еще
CScriptManager

теперь подробнее о каждом из менеджеров.

CFontManager - его задача предоставлять пользователю или программе доступ к любому из загруженых шрифтов
по его имени или id. А так по сути пока что он нихера не делает. И id еще не поддурживается.
// todo. неопределенность, толи делать толи нет.
 	Устанавливать шрифт как текущий
	Писать текст тексущим шрифтом
	Писать текст с тэгами
	писать текст через хитро закрученную жопу
// end todo list

CUpdateManager
	Хранит список объектов, для которых каждый кадр вызывается Update(dt);
CRenderManager
	Хранит список обхетов, для которых по истечение времени нужного чтобы поддерживать данный FPS лимит вызывается
	функция Draw();

CResourseManager
	Поддерживает запросы от пользователя, и не от пользователя что мол
//todo на самом деле я не знаю что из этого реализовано на данный момент	
	Загрузи всё из списка ресурсов (data/config/<четотам>.xml) // мб это при инициализации вызывать...
	Загрузи вот такой-то ресурс (принимает путь к ресурсу)
// end todo
	Еще этот менеджер не унаследован от CObjectList

К настоящему времени (21:50 28.11.2008) не реализованы (но очень планируется) такие вещи как:
Скриптовый язык
Движок пользовательского интерфейса (петя мудак, да)
Аудио (это тоже петя пусть делает ибо нех*й)


































