->
• We can switch between the two classes at runtime. As long as pSoundSystem
points to a valid object, the rest of the program doesn't know which one it is
using, so we can change them at will. Obviously, we have to be careful with spe-
cific class restrictions. For example, some classes will keep some state information
or require initialization before being used for the first time.
<-

->
We need to always include a virtual destructor in our abstract interfaces. If
we don't, C++ will automatically generate a nonvirtual destructor, which
will cause the real destructor of our specific implementation not to be called
(and that is usually a hard bug to track down). Unlike normal member
functions, we can't just provide a pure virtual destructor, so we need to create
an empty function to keep the compiler happy.
<-

->
Вообще-то идея засунуть полиморфные объекты ( объекты сцены ) в иерархическую структуру - хорошая и полезная идея. 

Так удобно конструировать игровой мир. Из палитры готовых запасных частей накликивать объекты. Вот есть монстр, 
к голове прилепим страшное красное свечение,
 на анимацию ходьбы по ключам развесим звук.
 А может и не звук - а партикл-эффекты под ногами. Или специальный компонент, 
который трясет камеру ( в зависимости от расстояния до монстра ). 

Полезно думать о Scene Graph как о конструкторе. Если мы говорим о конструкторе - 
то должны решительно забыть о составных частях - Spline, Sound, Mesh.
 А должны говорить именно про полиморфную  инфраструктуру.  Как родить, как убить, 
как прикрепить одно к другому.
 Есть SetPosition() у всех объектов? Отлично. Нету SetPosition()?
 У кого-то есть SetTransparency(), а у кого-то SetSoundVolume()?
 Еще лучше. Будут типизованные ивенты, которые спускаются вниз по иерархии. 

Т.е. у дизайна есть единственный двигатель - абстрагирование. Оно работает всюду, 
с высокого уровня до самого низкого. 

Вот видим мы в коде char  Name[NAMELEN]. Абстрагируемся, пусть будет String,
 с оператором конструирования от char *, оператором ==. Вопрос, стало ли лучше?
 Ответ - да, и сильно лучше. Даже тупо по перфомансу, так как допускается реализация,
 когда строки провешиваются в глобальный hash_set с рефкаунтом. Сравнение строк - сравнение указателя.
 Копирование строки - инкремент рефкаунта и копирование указателя. Инстанция строки занимает столько,
 сколько занимает указатель. Лучше? Да, лучше.
<-

->

<-